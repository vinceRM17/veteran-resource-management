---
phase: 01-foundation-crisis-safety
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/middleware.ts
  - src/middleware.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/layout.tsx
  - src/app/(auth)/auth/callback/route.ts
  - src/components/auth/LoginForm.tsx
  - src/components/auth/SignupForm.tsx
  - src/components/auth/OAuthButton.tsx
  - src/components/layout/Header.tsx
  - supabase/migrations/00001_initial_schema.sql
autonomous: false
user_setup:
  - service: supabase
    why: "Database, authentication, and Row-Level Security"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API -> Project URL"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> Project API keys -> anon/public"
      - name: SUPABASE_SERVICE_ROLE_KEY
        source: "Supabase Dashboard -> Project Settings -> API -> Project API keys -> service_role (keep secret)"
    dashboard_config:
      - task: "Create a new Supabase project"
        location: "https://supabase.com/dashboard -> New Project"
      - task: "Enable Google OAuth provider"
        location: "Supabase Dashboard -> Authentication -> Providers -> Google -> Enable, add Client ID and Secret from Google Cloud Console"
      - task: "Configure Google Cloud OAuth consent screen and credentials"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Create OAuth 2.0 Client ID (Web application, redirect URI: https://<project-ref>.supabase.co/auth/v1/callback)"
      - task: "Configure Site URL for auth redirects"
        location: "Supabase Dashboard -> Authentication -> URL Configuration -> Site URL: http://localhost:3000 (update for production later)"
      - task: "Add redirect URL"
        location: "Supabase Dashboard -> Authentication -> URL Configuration -> Redirect URLs: http://localhost:3000/auth/callback"

must_haves:
  truths:
    - "User can create an account with email and password"
    - "User can log in with existing email and password"
    - "User can sign in with Google OAuth and be redirected back to the app"
    - "User stays logged in across page refreshes and browser sessions"
    - "Logged-in user sees their email in the header; logged-out user sees login/signup links"
    - "Database has RLS enabled on sensitive tables and unauthorized queries return empty results"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser-side Supabase client using createBrowserClient"
      contains: "createBrowserClient"
    - path: "src/lib/supabase/server.ts"
      provides: "Server-side Supabase client for Server Components and Route Handlers"
      contains: "createServerClient"
    - path: "src/lib/supabase/middleware.ts"
      provides: "Middleware Supabase client for session refresh in Edge runtime"
      contains: "createServerClient"
    - path: "src/middleware.ts"
      provides: "Next.js middleware that refreshes auth session on every request"
      contains: "updateSession"
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page with email/password form and Google OAuth button"
      contains: "login"
    - path: "src/app/(auth)/signup/page.tsx"
      provides: "Signup page with email/password form and Google OAuth button"
      contains: "signup"
    - path: "src/app/(auth)/auth/callback/route.ts"
      provides: "OAuth callback handler that exchanges code for session"
      contains: "exchangeCodeForSession"
    - path: "supabase/migrations/00001_initial_schema.sql"
      provides: "Initial database schema with RLS policies"
      contains: "ENABLE ROW LEVEL SECURITY"
  key_links:
    - from: "src/middleware.ts"
      to: "src/lib/supabase/middleware.ts"
      via: "import updateSession function"
      pattern: "import.*updateSession"
    - from: "src/app/(auth)/login/page.tsx"
      to: "src/lib/supabase/client.ts"
      via: "Supabase auth.signInWithPassword"
      pattern: "signInWithPassword"
    - from: "src/app/(auth)/login/page.tsx"
      to: "src/lib/supabase/client.ts"
      via: "Supabase auth.signInWithOAuth for Google"
      pattern: "signInWithOAuth"
    - from: "src/app/(auth)/auth/callback/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "Exchange OAuth code for session"
      pattern: "exchangeCodeForSession"
    - from: "src/components/layout/Header.tsx"
      to: "src/lib/supabase/server.ts"
      via: "Check auth state to show user email or login link"
      pattern: "getUser"
---

<objective>
Set up Supabase authentication infrastructure with email/password and Google OAuth sign-in, create the database schema with Row-Level Security, and build the login/signup UI.

Purpose: Establish secure authentication (FOUND-02) and database-level data protection (FOUND-03) so that from this point forward, all veteran data is protected by RLS policies and users can create accounts and log in.

Output: Working authentication flow (email/password + Google OAuth), database schema with RLS policies, and auth-aware header showing user state.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/phases/01-foundation-crisis-safety/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set up Supabase clients, auth callback, and database schema with RLS</name>
  <files>
    src/lib/supabase/client.ts
    src/lib/supabase/server.ts
    src/lib/supabase/middleware.ts
    src/middleware.ts
    src/app/(auth)/auth/callback/route.ts
    supabase/migrations/00001_initial_schema.sql
  </files>
  <action>
    Create the three Supabase client variants following the official @supabase/ssr pattern for Next.js App Router.

    **src/lib/supabase/client.ts** (Browser client):
    ```typescript
    import { createBrowserClient } from "@supabase/ssr";

    export function createClient() {
      return createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
      );
    }
    ```

    **src/lib/supabase/server.ts** (Server client for Server Components and Route Handlers):
    - Use `createServerClient` from `@supabase/ssr`
    - Access cookies via `cookies()` from `next/headers` (async in Next.js 15+)
    - Set cookie options: `path: "/"`, `httpOnly: true`, `secure: true` in production
    - This client is used in Server Components, Server Actions, and Route Handlers

    **src/lib/supabase/middleware.ts** (Middleware client for Edge runtime):
    - Create an `updateSession` function that:
      1. Creates a Supabase server client with request/response cookie handling
      2. Calls `supabase.auth.getUser()` to refresh the session (IMPORTANT: use getUser() not getSession() - getSession reads from cookies which could be tampered with; getUser() validates against Supabase auth server)
      3. Returns the updated response with refreshed cookies
    - This runs on EVERY request to keep the session alive

    **src/middleware.ts** (Next.js middleware):
    - Import and call `updateSession` from `src/lib/supabase/middleware.ts`
    - Configure `matcher` to exclude static assets and API routes that don't need auth:
      ```typescript
      export const config = {
        matcher: [
          "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
        ],
      };
      ```
    - NOTE: This middleware only refreshes sessions. It does NOT block unauthenticated users from any routes yet (accounts are optional per project requirements - "guest mode screening is core value").

    **src/app/(auth)/auth/callback/route.ts** (OAuth callback):
    - Handle GET request with `code` query parameter
    - Create server Supabase client
    - Exchange code for session: `supabase.auth.exchangeCodeForSession(code)`
    - Redirect to home page on success
    - Redirect to login page with error on failure
    - This handles the redirect from Google OAuth (and any future OAuth providers)

    **supabase/migrations/00001_initial_schema.sql:**
    Create the initial database schema with RLS. Tables needed for Phase 1:

    ```sql
    -- Profiles table (extends Supabase auth.users)
    CREATE TABLE public.profiles (
      id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
      role TEXT NOT NULL DEFAULT 'veteran' CHECK (role IN ('veteran', 'caregiver', 'admin')),
      display_name TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );

    -- Enable RLS
    ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

    -- RLS Policies for profiles
    CREATE POLICY "Users can view own profile"
      ON public.profiles FOR SELECT
      USING (auth.uid() = id);

    CREATE POLICY "Users can update own profile"
      ON public.profiles FOR UPDATE
      USING (auth.uid() = id);

    CREATE POLICY "Users can insert own profile"
      ON public.profiles FOR INSERT
      WITH CHECK (auth.uid() = id);

    -- Trigger to auto-create profile on signup
    CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS TRIGGER AS $$
    BEGIN
      INSERT INTO public.profiles (id, role)
      VALUES (NEW.id, 'veteran');
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    CREATE TRIGGER on_auth_user_created
      AFTER INSERT ON auth.users
      FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

    -- Screening sessions table (for future phases, but RLS now)
    CREATE TABLE public.screening_sessions (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
      answers JSONB DEFAULT '{}',
      status TEXT NOT NULL DEFAULT 'in_progress' CHECK (status IN ('in_progress', 'completed', 'abandoned')),
      created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );

    ALTER TABLE public.screening_sessions ENABLE ROW LEVEL SECURITY;

    -- RLS: Users can only see their own screening sessions
    CREATE POLICY "Users can view own screening sessions"
      ON public.screening_sessions FOR SELECT
      USING (auth.uid() = user_id);

    CREATE POLICY "Users can create own screening sessions"
      ON public.screening_sessions FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    CREATE POLICY "Users can update own screening sessions"
      ON public.screening_sessions FOR UPDATE
      USING (auth.uid() = user_id);

    -- Anonymous sessions allowed (user_id can be null for guest mode)
    CREATE POLICY "Anonymous sessions are visible to creator"
      ON public.screening_sessions FOR SELECT
      USING (user_id IS NULL AND id = id);
    ```

    NOTE: The migration file is documentation and reference. The actual schema should be applied via Supabase Dashboard SQL editor or Supabase CLI. Include a comment at the top of the file: "-- Apply this migration via Supabase Dashboard -> SQL Editor or supabase db push".

    IMPORTANT: Do NOT use `auth.jwt()` for RLS policies - use `auth.uid()` which is the standard Supabase pattern and more secure.
  </action>
  <verify>
    1. Run `npm run build` - must compile without errors.
    2. Verify all three Supabase client files exist and export the correct functions.
    3. Verify middleware.ts exists and imports updateSession.
    4. Verify auth callback route exists at src/app/(auth)/auth/callback/route.ts.
    5. Verify migration file exists with RLS policies.
    6. Check that `.env.local` has placeholder Supabase env vars (from Plan 01).
  </verify>
  <done>
    Three Supabase client variants created (browser, server, middleware). Middleware refreshes auth session on every request. OAuth callback route exchanges code for session. Database migration defines profiles and screening_sessions tables with RLS policies ensuring users can only access their own data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build login and signup pages with email/password and Google OAuth</name>
  <files>
    src/app/(auth)/login/page.tsx
    src/app/(auth)/signup/page.tsx
    src/app/(auth)/layout.tsx
    src/components/auth/LoginForm.tsx
    src/components/auth/SignupForm.tsx
    src/components/auth/OAuthButton.tsx
    src/components/layout/Header.tsx
  </files>
  <action>
    Build the authentication UI following WCAG 2.1 AA accessibility standards.

    **src/app/(auth)/layout.tsx:**
    - Simple centered layout for auth pages
    - Max width container (max-w-md) centered on page
    - Inherits root layout (crisis banner still visible)

    **src/components/auth/OAuthButton.tsx:**
    - Reusable OAuth sign-in button component
    - Props: `provider` (string), `label` (string)
    - Uses Supabase browser client: `supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo: '${origin}/auth/callback' } })`
    - Styled with shadcn/ui Button variant="outline"
    - Google icon (use lucide-react or simple SVG)
    - Accessible: proper aria-label "Sign in with Google"
    - Loading state while OAuth redirect in progress

    **src/components/auth/LoginForm.tsx:**
    - Form with email and password fields
    - Use native form elements (not React Hook Form yet - keep it simple for Phase 1)
    - Client component ("use client") since it uses Supabase browser client
    - Form submission:
      1. Call `supabase.auth.signInWithPassword({ email, password })`
      2. On success: redirect to home page using `router.push('/')` or `router.refresh()`
      3. On error: display error message (e.g., "Invalid email or password")
    - Error display: use accessible alert with `role="alert"` and `aria-live="assertive"`
    - All fields have visible labels (not just placeholders) with `<label htmlFor="email">`
    - Required field indicators with aria-required="true"
    - Password field has show/hide toggle (accessible with aria-label)
    - Link to signup page: "Don't have an account? Sign up"

    **src/components/auth/SignupForm.tsx:**
    - Form with email, password, and confirm password fields
    - Client-side validation: password minimum 8 characters, passwords match
    - Form submission:
      1. Call `supabase.auth.signUp({ email, password, options: { emailRedirectTo: '${origin}/auth/callback' } })`
      2. On success: show message "Check your email for a confirmation link"
      3. On error: display error message
    - Same accessibility standards as LoginForm
    - Link to login page: "Already have an account? Log in"

    **src/app/(auth)/login/page.tsx:**
    - Page metadata: title "Log In - Veteran Resource Management"
    - Render LoginForm component
    - Render OAuthButton for Google below the form
    - Visual separator: "or" divider between form and OAuth button

    **src/app/(auth)/signup/page.tsx:**
    - Page metadata: title "Sign Up - Veteran Resource Management"
    - Render SignupForm component
    - Render OAuthButton for Google below the form
    - Visual separator: "or" divider between form and OAuth button

    **Update src/components/layout/Header.tsx:**
    - Make Header a Server Component that checks auth state
    - Use server Supabase client: `const { data: { user } } = await supabase.auth.getUser()`
    - If user is logged in: show user email and a "Log out" button
    - If user is NOT logged in: show "Log in" and "Sign up" links
    - Log out action: create a form with server action or client-side logout that calls `supabase.auth.signOut()` and redirects to home
    - Ensure logout button is accessible (not just an icon)

    **Accessibility requirements for all auth forms:**
    - Labels associated with inputs via htmlFor/id
    - Error messages linked to inputs via aria-describedby
    - Form submission feedback via aria-live regions
    - Focus management: auto-focus first field on page load
    - Tab order follows visual order
    - All buttons have descriptive text (not just icons)
    - Color is not the only indicator of errors (icon + text)
    - Min touch target 44x44px for mobile
  </action>
  <verify>
    1. Run `npm run build` - must compile without errors.
    2. Navigate to `/login` - form renders with email field, password field, login button, Google OAuth button.
    3. Navigate to `/signup` - form renders with email, password, confirm password, signup button, Google OAuth button.
    4. Tab through login form: focus moves through email -> password -> login button -> Google button -> signup link.
    5. Crisis banner is still visible on auth pages.
    6. Header shows "Log in" and "Sign up" links when not authenticated.
    7. All form fields have visible labels (not just placeholders).
    8. Verify aria-required attributes on required fields.
  </verify>
  <done>
    Login page works with email/password and Google OAuth button. Signup page works with email/password and Google OAuth button. Header shows auth state (user email when logged in, login/signup links when logged out). All forms meet WCAG 2.1 AA: labeled inputs, error announcements, keyboard navigable, proper focus management. Auth pages inherit root layout with crisis banner always visible.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify authentication flow end-to-end</name>
  <files>src/app/(auth)/login/page.tsx</files>
  <action>
    Human verification checkpoint. All code was built in Tasks 1-2. This task verifies the complete authentication system works end-to-end:
    - Supabase project connected (env vars configured)
    - Email/password signup and login
    - Google OAuth sign-in
    - Session persistence across page refreshes
    - Auth-aware header (shows user email or login/signup links)
    - Database schema with RLS policies on profiles and screening_sessions tables
    - Crisis banner still visible on all pages including auth pages
  </action>
  <verify>
    Prerequisites: You must have completed the user_setup items (Supabase project created, env vars in .env.local, Google OAuth configured in Supabase dashboard).

    1. Start dev server: `npm run dev`
    2. Visit http://localhost:3000 - verify crisis banner is visible, header shows "Log in" / "Sign up" links
    3. Click "Sign up" - verify form renders with email, password, confirm password fields
    4. Create an account with email/password - verify confirmation message appears
    5. (If email confirmation is disabled in Supabase) Log in with the account - verify redirect to home, header shows email
    6. Refresh the page - verify you're still logged in (session persists)
    7. Click "Log out" - verify redirect to home, header shows login/signup links again
    8. Test Google OAuth: click "Sign in with Google" - verify redirect to Google, then back to app with session
    9. Verify RLS: Open Supabase Dashboard -> SQL Editor, run:
       ```sql
       -- Should return the profile for the logged-in user only
       SELECT * FROM profiles;
       ```
    10. Verify keyboard navigation works on login and signup forms

    Resume signal: Type "approved" to continue, or describe any issues found.
  </verify>
  <done>
    User confirmed: authentication works with email/password and Google OAuth. Session persists across refresh. Header shows auth state. RLS policies active. Crisis banner visible on all auth pages.
  </done>
</task>

</tasks>

<verification>
1. **FOUND-02 (Authentication):** User can sign up and log in with email/password. User can sign in with Google OAuth. Session persists across page refreshes. Header reflects auth state.
2. **FOUND-03 (Row-Level Security):** profiles table has RLS enabled with policies for SELECT, INSERT, UPDATE limited to auth.uid(). screening_sessions table has RLS enabled with user-scoped policies. Migration file documents all policies.
3. **Auth Infrastructure:** Three Supabase client variants work correctly (browser, server, middleware). Middleware refreshes session on every request. OAuth callback exchanges code for session.
4. **Accessibility:** Auth forms have labeled inputs, error announcements, keyboard navigation, and proper focus management. Crisis banner visible on auth pages.
</verification>

<success_criteria>
- User can create account with email/password and log in successfully
- User can sign in with Google OAuth and be redirected back
- Session persists across page refresh (middleware refreshing cookies)
- Header shows user email when logged in, login/signup links when logged out
- `npm run build` succeeds with zero errors
- RLS policies exist on profiles and screening_sessions tables
- All auth forms pass keyboard navigation test
- Crisis banner visible on login and signup pages
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-crisis-safety/01-02-SUMMARY.md`
</output>
