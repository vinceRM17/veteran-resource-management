---
phase: 04-smart-crisis-detection
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/components/crisis/CrisisIntercept.tsx
  - src/content/screening-questions.ts
  - src/lib/screening/schemas.ts
  - src/app/screening/actions.ts
  - src/app/screening/intake/step-4/page.tsx
  - src/app/screening/intake/review/page.tsx
autonomous: false

must_haves:
  truths:
    - "When crisis keywords are detected in screening answers, server action returns crisisDetected signal before eligibility evaluation"
    - "CrisisIntercept renders as full-page overlay with 988 Lifeline, Crisis Text Line, and VA Crisis Line with one-click call/text"
    - "User can dismiss CrisisIntercept and continue to screening results (not blocked)"
    - "Eligibility evaluation still completes in background when crisis is detected"
    - "Optional free-text field on step 4 allows veteran to share additional context"
    - "Focus management: CrisisIntercept traps focus, returns focus on dismiss, Escape key dismisses"
  artifacts:
    - path: "src/components/crisis/CrisisIntercept.tsx"
      provides: "Full-page accessible crisis intervention modal"
      exports: ["CrisisIntercept"]
      min_lines: 60
    - path: "src/app/screening/actions.ts"
      provides: "Updated server action with crisis detection before eligibility evaluation"
      exports: ["submitScreening"]
      contains: "detectCrisis"
    - path: "src/content/screening-questions.ts"
      provides: "Updated screening questions with optional free-text field on step 4"
      contains: "additionalInfo"
  key_links:
    - from: "src/app/screening/actions.ts"
      to: "src/lib/crisis/detector.ts"
      via: "calls detectCrisis on extracted text before eligibility evaluation"
      pattern: "import.*detectCrisis.*from.*crisis/detector"
    - from: "src/app/screening/actions.ts"
      to: "src/lib/crisis/logger.ts"
      via: "calls logCrisisDetection when crisis detected"
      pattern: "import.*logCrisisDetection.*from.*crisis/logger"
    - from: "src/app/screening/intake/review/page.tsx"
      to: "src/components/crisis/CrisisIntercept.tsx"
      via: "renders CrisisIntercept when server action returns crisisDetected"
      pattern: "import.*CrisisIntercept.*from.*crisis/CrisisIntercept"
---

<objective>
Wire crisis detection into the screening flow end-to-end: add an optional free-text field to capture crisis language, modify the server action to detect crisis before evaluation, build the accessible CrisisIntercept modal, and integrate everything so crisis detection triggers the intervention overlay while still completing eligibility evaluation.

Purpose: This is the core user-facing plan that delivers the Phase 4 value proposition. When a veteran types something indicating crisis, they immediately see help resources. The intervention is non-blocking (they can continue to results) and the eligibility evaluation completes in the background.

Output: CrisisIntercept component, updated server action, free-text field on step 4, updated review page with crisis handling.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-smart-crisis-detection/04-RESEARCH.md
@.planning/phases/04-smart-crisis-detection/04-01-SUMMARY.md

# Existing files being modified
@src/app/screening/actions.ts
@src/app/screening/intake/step-4/page.tsx
@src/app/screening/intake/review/page.tsx
@src/content/screening-questions.ts
@src/lib/screening/schemas.ts
@src/components/crisis/CrisisBanner.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CrisisIntercept component and add free-text field to screening</name>
  <files>
    src/components/crisis/CrisisIntercept.tsx
    src/content/screening-questions.ts
    src/lib/screening/schemas.ts
    src/app/screening/intake/step-4/page.tsx
  </files>
  <action>
    **CrisisIntercept component** (`src/components/crisis/CrisisIntercept.tsx`):

    Create a "use client" component that renders a full-page crisis intervention overlay:

    Props: `{ onDismiss: () => void; sessionId?: string }`

    Implementation:
    1. Full viewport overlay: `fixed inset-0 z-[100] bg-white` (covers everything including CrisisBanner)
    2. Content area centered with max-w-2xl, proper padding
    3. Heading: "You Are Not Alone" (h1, id="crisis-title", large bold text in red-900)
    4. Subheading: "We noticed you might be going through a tough time. Please reach out — help is available right now." (at 6th grade reading level)
    5. Three large, accessible action buttons (full-width, min 44px height for touch targets):
       - "Call 988 Suicide & Crisis Lifeline" -> href="tel:988" (Phone icon from lucide-react)
       - "Text HOME to 741741" -> href="sms:741741&body=HELLO" (MessageCircle icon)
       - "Call Veterans Crisis Line: 1-800-273-8255" -> href="tel:18002738255" (Phone icon)
       - Style: bg-red-900 text-white text-xl font-bold py-6 px-8 rounded-lg with hover and focus-visible states
    6. "Continue to your results" dismiss button at bottom:
       - Style: border-2 border-gray-600 text-gray-900, not prominent (crisis resources should be primary)
       - Calls onDismiss when clicked
    7. Accessibility:
       - `role="dialog"` and `aria-modal="true"` on container
       - `aria-labelledby="crisis-title"` pointing to the heading
       - Focus trap: on mount, save `document.activeElement`, focus the first crisis link. On unmount, restore focus to previously focused element.
       - Keyboard: Escape key calls onDismiss
       - Focus trap loop: Tab from last element wraps to first, Shift+Tab from first wraps to last. Use a `useEffect` with keydown listener that intercepts Tab at boundary elements.
    8. Prevent body scroll while modal is open: add `overflow-hidden` to document.body on mount, remove on unmount.

    Follow the same icon import pattern as CrisisBanner.tsx (import Phone, MessageCircle from lucide-react).

    **Add free-text field to screening questions** (`src/content/screening-questions.ts`):

    Add a new question to step 4 (the "What You Need" step):
    ```typescript
    {
      id: "additionalInfo",
      label: "Is there anything else you want us to know?",
      type: "textarea" as QuestionType, // Need to add "textarea" to QuestionType union
      options: [], // Not applicable for textarea
      required: false,
      helpText: "This is optional. You can share anything that might help us find the right resources for you.",
    }
    ```

    Update the `QuestionType` union to include `"textarea"`.

    **Update Zod schema** (`src/lib/screening/schemas.ts`):

    Add `additionalInfo` to the step 4 schema as `z.string().max(1000).optional()`. This is the only field that needs crisis detection scanning.

    **Update Step 4 page** (`src/app/screening/intake/step-4/page.tsx`):

    Add a textarea input for the `additionalInfo` question after the existing checkbox groups:
    1. Add local state: `const [additionalInfo, setAdditionalInfo] = useState<string>(answers.additionalInfo as string || "")`
    2. Initialize from store in useEffect (same pattern as areasOfNeed/currentBenefits)
    3. Render a QuestionCard with a `<textarea>` element:
       - className matching the project's input styling (border rounded-md p-3, etc.)
       - maxLength={1000}
       - rows={4}
       - placeholder="Optional — share anything on your mind"
       - aria-describedby pointing to help text
    4. Include additionalInfo in setAnswers calls (handleNext and handleBack)
    5. Include additionalInfo in step4Schema.safeParse payload
  </action>
  <verify>
    - CrisisIntercept.tsx exists with role="dialog", aria-modal="true", aria-labelledby
    - Component renders 988 Lifeline, Crisis Text Line, and VA Crisis Line links
    - Focus trap implemented (useEffect with keydown listener)
    - Escape key handler calls onDismiss
    - screening-questions.ts includes "textarea" in QuestionType and additionalInfo question in step 4
    - schemas.ts includes additionalInfo as optional string in step 4 schema
    - Step 4 page renders textarea for additionalInfo
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    CrisisIntercept component is fully accessible with focus trap, keyboard navigation, and screen reader support. Step 4 has optional free-text field enabling crisis keyword detection. All crisis resources have one-click call/text actions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire crisis detection into server action and review page</name>
  <files>
    src/app/screening/actions.ts
    src/app/screening/intake/review/page.tsx
  </files>
  <action>
    **Update server action** (`src/app/screening/actions.ts`):

    Modify `submitScreening` to run crisis detection BEFORE eligibility evaluation:

    1. Add imports at top:
       ```typescript
       import { detectCrisis, extractTextFromAnswers } from "@/lib/crisis/detector";
       import { logCrisisDetection } from "@/lib/crisis/logger";
       ```

    2. After the required field validation (answers.role, answers.state), add crisis detection:
       ```typescript
       // CRISIS DETECTION — runs before eligibility evaluation
       const textContent = extractTextFromAnswers(answers);
       const crisisResult = detectCrisis(textContent);

       let crisisLogId: string | null = null;
       if (crisisResult) {
         crisisLogId = await logCrisisDetection({ result: crisisResult });
       }
       ```

    3. Change the return type to include crisis info:
       ```typescript
       Promise<{ sessionId?: string; error?: string; crisisDetected?: boolean; crisisLogId?: string | null }>
       ```

    4. IMPORTANT: Do NOT short-circuit on crisis detection. The eligibility evaluation MUST still complete. The research recommends completing evaluation in background so user can see results after viewing crisis resources.

    5. After saving the session (after the existing `supabase.from("screening_sessions").insert(...)` block), if crisis was detected, update the crisis log with the session ID:
       ```typescript
       if (crisisResult && crisisLogId) {
         // Link crisis log to the screening session
         await supabase
           .from("crisis_detection_logs")
           .update({ screening_session_id: session.id })
           .eq("id", crisisLogId);
       }
       ```

    6. In the final return, include crisis detection info:
       ```typescript
       return {
         sessionId: session.id,
         crisisDetected: crisisResult !== null,
         crisisLogId,
       };
       ```

    **Update review page** (`src/app/screening/intake/review/page.tsx`):

    Modify `handleSubmit` and the component to handle crisis detection response:

    1. Add state for crisis display:
       ```typescript
       const [showCrisisIntercept, setShowCrisisIntercept] = useState(false);
       const [pendingSessionId, setPendingSessionId] = useState<string | null>(null);
       ```

    2. Import CrisisIntercept:
       ```typescript
       import { CrisisIntercept } from "@/components/crisis/CrisisIntercept";
       ```

    3. Modify `handleSubmit`:
       - After getting result from submitScreening, check `result.crisisDetected`
       - If crisis detected: set `pendingSessionId` to `result.sessionId`, set `showCrisisIntercept` to true, set `isSubmitting` to false (so the form is interactive again behind the modal)
       - If no crisis: proceed with existing flow (reset() and router.push to results)

    4. Add crisis dismiss handler:
       ```typescript
       function handleCrisisDismiss() {
         setShowCrisisIntercept(false);
         if (pendingSessionId) {
           reset();
           router.push(`/screening/results/${pendingSessionId}`);
         }
       }
       ```

    5. Render CrisisIntercept conditionally:
       ```typescript
       {showCrisisIntercept && (
         <CrisisIntercept
           onDismiss={handleCrisisDismiss}
           sessionId={pendingSessionId ?? undefined}
         />
       )}
       ```
       Place this BEFORE the main content div so it renders on top.

    6. Also add additionalInfo to the review display. In the step4Items section, add:
       ```typescript
       if (answers.additionalInfo && typeof answers.additionalInfo === "string" && answers.additionalInfo.trim()) {
         step4Items.push({
           label: "Additional information",
           value: answers.additionalInfo as string,
         });
       }
       ```
  </action>
  <verify>
    - actions.ts imports detectCrisis and logCrisisDetection
    - actions.ts runs crisis detection before eligibility evaluation
    - actions.ts does NOT short-circuit — eligibility still evaluates even when crisis detected
    - actions.ts returns crisisDetected boolean in response
    - review/page.tsx imports and renders CrisisIntercept conditionally
    - review/page.tsx shows CrisisIntercept when crisisDetected is true
    - review/page.tsx navigates to results after CrisisIntercept is dismissed
    - review/page.tsx shows additionalInfo in review section
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    End-to-end crisis detection wired: server action detects crisis keywords, logs audit record, continues eligibility evaluation, signals client. Review page shows CrisisIntercept overlay on detection, then navigates to results on dismiss. Free-text field content visible in review.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end crisis detection flow</name>
  <files>src/app/screening/intake/review/page.tsx</files>
  <action>
    Human verification of the complete crisis detection flow. What was built:
    Complete crisis detection flow: optional free-text field on step 4, server-side keyword detection in server action, full-page CrisisIntercept modal with accessible crisis resources (988, Crisis Text Line, VA Crisis Line), and audit logging.
  </action>
  <verify>
    1. Apply migration 00006 via Supabase Dashboard SQL Editor
    2. Start dev server: `npm run dev`
    3. Navigate to /screening/intake/step-1 and complete steps 1-3
    4. On step 4, in the "Is there anything else?" textarea, type: "I feel hopeless and like there's no point"
    5. Complete the review and click Submit
    6. Verify: CrisisIntercept modal appears with:
       - "You Are Not Alone" heading
       - 988 Lifeline call link
       - Crisis Text Line text link
       - VA Crisis Line call link
       - "Continue to your results" button
    7. Verify accessibility: Tab through the modal (focus should stay trapped), press Escape (modal should dismiss)
    8. Click "Continue to your results" — should navigate to results page with eligibility matches
    9. In Supabase Dashboard, check crisis_detection_logs table — should have a row with detected_keywords containing "hopeless" and "no point"
    10. Test non-crisis path: complete screening without crisis text — no intercept should appear
  </verify>
  <done>
    Human has verified: crisis detection triggers CrisisIntercept on crisis text, intercept is accessible, results still load after dismiss, audit log created, non-crisis path unaffected.
    Resume signal: Type "approved" or describe issues.
  </done>
</task>

</tasks>

<verification>
- Crisis detection runs server-side before eligibility evaluation
- CrisisIntercept is fully accessible (focus trap, ARIA, keyboard)
- Free-text field is optional and has 1000 character limit
- Eligibility evaluation completes even when crisis is detected
- Audit log created with detected keywords (no raw text stored)
- Non-crisis screenings are unaffected
</verification>

<success_criteria>
- Typing crisis keywords in free-text field triggers CrisisIntercept
- CrisisIntercept shows 988, Crisis Text Line, and VA Crisis Line
- User can dismiss CrisisIntercept and see their results
- Audit record exists in crisis_detection_logs
- Non-crisis submissions work as before
- All accessibility requirements met (focus trap, keyboard nav, ARIA)
</success_criteria>

<output>
After completion, create `.planning/phases/04-smart-crisis-detection/04-02-SUMMARY.md`
</output>
