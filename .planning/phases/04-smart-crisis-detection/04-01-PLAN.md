---
phase: 04-smart-crisis-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00006_crisis_detection.sql
  - src/lib/crisis/keywords.ts
  - src/lib/crisis/detector.ts
  - src/lib/crisis/logger.ts
  - src/lib/crisis/types.ts
autonomous: true

must_haves:
  truths:
    - "Crisis keyword list contains clinically validated phrases derived from ASQ screening tool"
    - "detectCrisis() function scans text for crisis keywords and returns detected matches with severity weights"
    - "logCrisisDetection() function inserts audit record into crisis_detection_logs table via Supabase"
    - "crisis_detection_logs table exists with RLS restricting reads to admin role"
  artifacts:
    - path: "supabase/migrations/00006_crisis_detection.sql"
      provides: "crisis_detection_logs table with indexes, RLS policies, and cleanup function"
      contains: "CREATE TABLE.*crisis_detection_logs"
    - path: "src/lib/crisis/keywords.ts"
      provides: "Validated crisis keyword list with severity weights"
      exports: ["CRISIS_KEYWORDS", "CrisisKeyword"]
    - path: "src/lib/crisis/detector.ts"
      provides: "Crisis detection function scanning text for keyword matches"
      exports: ["detectCrisis"]
    - path: "src/lib/crisis/logger.ts"
      provides: "Audit trail logging for crisis detection events"
      exports: ["logCrisisDetection"]
    - path: "src/lib/crisis/types.ts"
      provides: "TypeScript types for crisis detection system"
      exports: ["CrisisDetectionResult", "CrisisLogEntry"]
  key_links:
    - from: "src/lib/crisis/detector.ts"
      to: "src/lib/crisis/keywords.ts"
      via: "imports CRISIS_KEYWORDS for matching"
      pattern: "import.*CRISIS_KEYWORDS.*from.*keywords"
    - from: "src/lib/crisis/logger.ts"
      to: "supabase/migrations/00006_crisis_detection.sql"
      via: "inserts into crisis_detection_logs table"
      pattern: "from.*crisis_detection_logs"
---

<objective>
Create the server-side crisis detection foundation: database schema for audit logging, clinically validated keyword list, detection algorithm, and audit logger.

Purpose: Establish the backend infrastructure that all crisis detection features depend on. The keyword list uses ASQ-derived phrases (not general sentiment analysis) to minimize false positives. The detector runs as a pure function for testability. The logger writes HIPAA-compliant audit records.

Output: Migration SQL file, crisis keyword definitions, detection function, audit logging function, TypeScript types.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-smart-crisis-detection/04-RESEARCH.md

# Existing patterns to follow
@src/lib/supabase/server.ts
@src/lib/eligibility/engine.ts
@supabase/migrations/00004_screening_eligibility.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create crisis detection database schema and TypeScript types</name>
  <files>
    supabase/migrations/00006_crisis_detection.sql
    src/lib/crisis/types.ts
  </files>
  <action>
    Create migration `00006_crisis_detection.sql` with:

    1. `crisis_detection_logs` table:
       - `id` UUID PRIMARY KEY DEFAULT gen_random_uuid()
       - `screening_session_id` UUID REFERENCES screening_sessions(id) ON DELETE SET NULL (nullable, may not have session yet)
       - `detected_keywords` TEXT[] NOT NULL (array of matched keywords)
       - `keyword_severities` TEXT[] NOT NULL (parallel array: 'high' | 'medium' for each keyword)
       - `max_severity` TEXT NOT NULL CHECK (max_severity IN ('high', 'medium'))
       - `source_text_hash` TEXT NOT NULL (SHA-256 hash of analyzed text, NOT the raw text itself — avoid storing PHI)
       - `detected_at` TIMESTAMPTZ NOT NULL DEFAULT now()
       - `reviewed_by` UUID REFERENCES auth.users(id) ON DELETE SET NULL (nullable)
       - `reviewed_at` TIMESTAMPTZ (nullable)
       - `is_false_positive` BOOLEAN (nullable, set during review)
       - `review_notes` TEXT (nullable)
       - `created_at` TIMESTAMPTZ NOT NULL DEFAULT now()

    2. Indexes:
       - `idx_crisis_logs_detected_at` on (detected_at DESC) for dashboard queries
       - `idx_crisis_logs_unreviewed` on (reviewed_at) WHERE reviewed_at IS NULL for monitoring queue
       - `idx_crisis_logs_session` on (screening_session_id) for session lookup

    3. RLS policies:
       - Enable RLS on table
       - "Service role inserts crisis logs" — no INSERT policy (service role bypasses RLS)
       - "Admins can view crisis logs" — SELECT for authenticated users. For now, use a simple check: `auth.uid() IS NOT NULL` since we don't have a user_roles table yet. Add a SQL comment noting this should be tightened to admin-only when user roles are implemented in Phase 5.
       - "Admins can update crisis logs" — UPDATE for authenticated users (same caveat as above, comment about Phase 5 tightening). Only allow updating: reviewed_by, reviewed_at, is_false_positive, review_notes.

    4. Cleanup function (for future scheduling):
       ```sql
       CREATE OR REPLACE FUNCTION cleanup_old_crisis_logs()
       RETURNS void AS $$
       BEGIN
         DELETE FROM crisis_detection_logs
         WHERE detected_at < now() - interval '6 years';
       END;
       $$ LANGUAGE plpgsql;
       ```
       Add comment: "Schedule with pg_cron when available: SELECT cron.schedule('cleanup-crisis-logs', '0 2 * * 0', 'SELECT cleanup_old_crisis_logs()');"

    5. Enable Realtime for crisis_detection_logs (needed for monitoring dashboard):
       ```sql
       ALTER PUBLICATION supabase_realtime ADD TABLE crisis_detection_logs;
       ```

    Create `src/lib/crisis/types.ts` with TypeScript types:
    - `CrisisKeyword`: { phrase: string; severity: 'high' | 'medium'; category: string }
    - `CrisisDetectionResult`: { detected: boolean; keywords: string[]; severities: ('high' | 'medium')[]; maxSeverity: 'high' | 'medium'; sourceTextHash: string }
    - `CrisisLogEntry`: { id: string; screening_session_id: string | null; detected_keywords: string[]; keyword_severities: string[]; max_severity: string; source_text_hash: string; detected_at: string; reviewed_by: string | null; reviewed_at: string | null; is_false_positive: boolean | null; review_notes: string | null }

    Follow existing migration style from 00004_screening_eligibility.sql. Include header comment about applying via Supabase Dashboard SQL Editor.
  </action>
  <verify>
    - File exists at supabase/migrations/00006_crisis_detection.sql
    - SQL contains CREATE TABLE crisis_detection_logs with all specified columns
    - SQL contains RLS policies and indexes
    - SQL contains cleanup function and realtime publication
    - Types file exports CrisisDetectionResult and CrisisLogEntry
    - `npx tsc --noEmit` passes (types are valid TypeScript)
  </verify>
  <done>
    Migration file ready for manual application. Types file provides type safety for all crisis detection code. RLS restricts crisis logs to authenticated users with comment about future admin-only restriction.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create crisis keyword list, detector function, and audit logger</name>
  <files>
    src/lib/crisis/keywords.ts
    src/lib/crisis/detector.ts
    src/lib/crisis/logger.ts
  </files>
  <action>
    Create `src/lib/crisis/keywords.ts`:

    Export `CRISIS_KEYWORDS` as an array of `CrisisKeyword` objects. Use ASQ-derived, clinically validated phrases. Organize into two severity tiers:

    **High severity (suicidal ideation indicators):**
    - "kill myself", "end my life", "want to die", "better off dead", "no reason to live", "end it all", "suicide", "suicidal", "take my own life", "don't want to be here", "wish I was dead", "rather be dead", "can't go on anymore", "no way out", "plan to end"

    **Medium severity (acute distress indicators):**
    - "hopeless", "worthless", "no point", "give up", "can't take it", "nobody cares", "all alone", "burden to everyone", "nothing matters", "what's the point", "trapped", "unbearable"

    Include category labels: "suicidal_ideation" for high, "acute_distress" for medium.

    IMPORTANT: Use phrase matching (multi-word), not single word matching. "kill" alone should NOT match (avoids "kill time", "kill two birds"). The keyword list should match whole phrases within text, case-insensitive.

    Create `src/lib/crisis/detector.ts`:

    Export `detectCrisis(textContent: string): CrisisDetectionResult | null`

    Implementation:
    1. Normalize input: lowercase, collapse whitespace
    2. Iterate CRISIS_KEYWORDS, check if phrase appears in normalized text
    3. Collect all matches with their severities
    4. If no matches, return null
    5. Compute maxSeverity (high if any high keyword matched, else medium)
    6. Compute SHA-256 hash of the original textContent using Web Crypto API (`crypto.subtle.digest` — available in Node.js and Edge runtime). Store as hex string.
    7. Return CrisisDetectionResult with detected: true, keywords array, severities array, maxSeverity, and sourceTextHash

    Also export `extractTextFromAnswers(answers: Record<string, unknown>): string` that:
    1. Iterates all values in the answers object
    2. Collects string values (skip arrays, numbers, booleans, nulls)
    3. Joins with spaces
    4. This is what gets passed to detectCrisis()

    Note: Since current screening has NO free-text fields, this function will mostly find nothing in existing structured answers. Plan 04-02 adds an optional free-text field. The detector is designed to handle both.

    Create `src/lib/crisis/logger.ts`:

    Export `logCrisisDetection(params: { sessionId?: string; result: CrisisDetectionResult }): Promise<string | null>`

    Implementation:
    1. Import createClient from `@/lib/supabase/server` (server-side client)
    2. Insert into crisis_detection_logs:
       - screening_session_id: params.sessionId ?? null
       - detected_keywords: params.result.keywords
       - keyword_severities: params.result.severities
       - max_severity: params.result.maxSeverity
       - source_text_hash: params.result.sourceTextHash
    3. Return the inserted row's id, or null on error
    4. Catch errors and console.error (do NOT throw — crisis logging failure must not block the user flow)

    Use the same Supabase server client pattern as existing code (await createClient()). The server action runs with the anon key, but inserts work because there's no INSERT RLS policy (service role handles it). Wait — actually the server action uses the anon key client, which IS subject to RLS. Since we have no INSERT policy, anon inserts will be BLOCKED by RLS.

    Solution: Add an INSERT policy in the migration that allows any connection to insert (similar to how screening_sessions allows anonymous inserts):
    ```sql
    CREATE POLICY "Anyone can insert crisis logs"
      ON crisis_detection_logs FOR INSERT
      WITH CHECK (true);
    ```
    This is acceptable because crisis logs contain no PHI (only keyword names and a text hash), and we WANT to capture crisis events even from anonymous users.
  </action>
  <verify>
    - keywords.ts exports CRISIS_KEYWORDS with at least 15 high-severity and 10 medium-severity phrases
    - detector.ts exports detectCrisis and extractTextFromAnswers
    - detectCrisis("I want to kill myself") returns result with detected: true, keywords containing "kill myself", maxSeverity "high"
    - detectCrisis("I like pizza") returns null
    - detectCrisis("I want to kill time") returns null (phrase matching, not word matching)
    - logger.ts exports logCrisisDetection
    - `npx tsc --noEmit` passes
  </verify>
  <done>
    Crisis detection engine ready: keyword list loaded, detector matches phrases with severity weights, logger writes audit records. Pure function design enables unit testing. Phrase matching minimizes false positives from common words.
  </done>
</task>

</tasks>

<verification>
- Migration 00006 is syntactically valid SQL
- TypeScript compilation passes with no errors
- detectCrisis returns correct results for crisis text and null for non-crisis text
- Phrase matching prevents false positives (e.g., "kill time" does not trigger)
- All exports are properly typed
</verification>

<success_criteria>
- crisis_detection_logs migration ready for manual application
- detectCrisis() correctly identifies crisis keywords with severity levels
- logCrisisDetection() writes audit records to Supabase
- extractTextFromAnswers() collects string values from screening answers
- No new npm dependencies required
</success_criteria>

<output>
After completion, create `.planning/phases/04-smart-crisis-detection/04-01-SUMMARY.md`
</output>
