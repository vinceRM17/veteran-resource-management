---
phase: 05-user-accounts-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00007_user_accounts_dashboard.sql
  - src/lib/db/dashboard-types.ts
  - src/app/screening/actions.ts
  - src/app/(auth)/auth/callback/route.ts
  - src/app/(auth)/signup/page.tsx
  - src/components/auth/SignupForm.tsx
autonomous: true

must_haves:
  truths:
    - "Bookmarks and action_items tables exist in database with proper RLS"
    - "Crisis log RLS is tightened to admin-only (profile role = admin)"
    - "Guest screening sessions can be claimed by a newly created account"
    - "Auth callback supports redirect to a custom page after signup"
  artifacts:
    - path: "supabase/migrations/00007_user_accounts_dashboard.sql"
      provides: "bookmarks, action_items tables, admin RLS update, session-claiming function"
      contains: "CREATE TABLE public.bookmarks"
    - path: "src/lib/db/dashboard-types.ts"
      provides: "TypeScript types for bookmarks and action items"
      exports: ["Bookmark", "ActionItem", "ScreeningHistoryEntry"]
    - path: "src/app/screening/actions.ts"
      provides: "claimGuestSession server action"
      contains: "claimGuestSession"
  key_links:
    - from: "src/app/screening/actions.ts"
      to: "supabase screening_sessions table"
      via: "UPDATE user_id WHERE id = sessionId AND user_id IS NULL"
      pattern: "user_id.*null"
    - from: "src/app/(auth)/auth/callback/route.ts"
      to: "redirect URL"
      via: "searchParams.get('next')"
      pattern: "next.*redirect"
---

<objective>
Create the database foundation for Phase 5: bookmarks table, action_items table, admin-only RLS for crisis logs, session-claiming logic, and TypeScript types. Also update auth callback to support redirect after signup so users can be sent to dashboard.

Purpose: All Phase 5 features depend on these tables and the ability to claim guest sessions after account creation.
Output: Migration SQL, TypeScript types, session-claiming server action, updated auth flow.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Key existing files:
@supabase/migrations/00001_initial_schema.sql — profiles table with role column (veteran/caregiver/admin), screening_sessions with user_id nullable
@supabase/migrations/00004_screening_eligibility.sql — screening_results table with session_id FK
@supabase/migrations/00005_screening_rls_update.sql — current permissive RLS for guest screening
@supabase/migrations/00006_crisis_detection.sql — crisis_detection_logs with TODO comments for Phase 5 admin RLS
@src/lib/db/screening-types.ts — existing ScreeningSession, ScreeningResult, ProgramMatch types
@src/app/screening/actions.ts — submitScreening server action (saves session with user_id: user?.id || null)
@src/app/(auth)/auth/callback/route.ts — auth callback with `next` param support already
@src/components/auth/SignupForm.tsx — existing signup form
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration for bookmarks, action items, admin RLS, and session claiming</name>
  <files>supabase/migrations/00007_user_accounts_dashboard.sql, src/lib/db/dashboard-types.ts</files>
  <action>
Create migration `supabase/migrations/00007_user_accounts_dashboard.sql` with:

**1. Bookmarks table:**
```sql
CREATE TABLE public.bookmarks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  resource_type TEXT NOT NULL CHECK (resource_type IN ('organization', 'business', 'program')),
  resource_id TEXT NOT NULL,
  resource_name TEXT NOT NULL,
  notes TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, resource_type, resource_id)
);
```
- RLS: Users can CRUD their own bookmarks only (auth.uid() = user_id for all policies)
- Index on (user_id, created_at DESC)

**2. Action items table:**
```sql
CREATE TABLE public.action_items (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  session_id UUID REFERENCES public.screening_sessions(id) ON DELETE SET NULL,
  program_id TEXT,
  program_name TEXT,
  title TEXT NOT NULL,
  description TEXT,
  is_completed BOOLEAN NOT NULL DEFAULT false,
  completed_at TIMESTAMPTZ,
  sort_order INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```
- RLS: Users can CRUD their own action items only (auth.uid() = user_id)
- Index on (user_id, is_completed, sort_order)
- Auto-update trigger for updated_at (reuse pattern from eligibility_rules)

**3. Tighten crisis_detection_logs RLS to admin-only:**
```sql
-- Drop old permissive policies
DROP POLICY IF EXISTS "Authenticated users can view crisis logs" ON public.crisis_detection_logs;
DROP POLICY IF EXISTS "Authenticated users can update crisis logs" ON public.crisis_detection_logs;

-- New admin-only policies using profiles.role
CREATE POLICY "Admin users can view crisis logs"
  ON public.crisis_detection_logs FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
  );

CREATE POLICY "Admin users can update crisis logs"
  ON public.crisis_detection_logs FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'admin'
    )
  );
```
Keep the "Anyone can insert crisis logs" policy unchanged (anonymous insertion must work).

**4. Helper function to check admin role:**
```sql
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = auth.uid() AND role = 'admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;
```

**5. Update screening_sessions RLS to allow authenticated users to UPDATE their own sessions (for claiming):**
Add policy if not exists:
```sql
CREATE POLICY "Users can update own screening sessions"
  ON public.screening_sessions FOR UPDATE
  USING (auth.uid() = user_id OR user_id IS NULL)
  WITH CHECK (auth.uid() = user_id);
```
This allows a logged-in user to claim a guest session (user_id IS NULL) by setting user_id to their own ID. The WITH CHECK ensures they can only set it to their own user_id.

Then create `src/lib/db/dashboard-types.ts` with TypeScript interfaces:
- `Bookmark` interface matching the bookmarks table
- `ActionItem` interface matching the action_items table
- `ScreeningHistoryEntry` — a view type: `{ id, answers, role, status, created_at, results: { program_name, confidence, confidence_label }[] }`
- Export all types

Note: This migration must be applied manually via Supabase Dashboard SQL Editor, same as all prior migrations.
  </action>
  <verify>
Read the migration file and verify:
1. All 4 sections present (bookmarks, action_items, crisis RLS, screening update RLS)
2. All tables have RLS enabled and correct policies
3. TypeScript types file exports match table schemas
Run `npx tsc --noEmit` to verify no type errors.
  </verify>
  <done>
Migration file ready for manual application. TypeScript types compile cleanly. bookmarks table has unique constraint on (user_id, resource_type, resource_id). action_items table has user_id FK and session_id FK. Crisis log policies restricted to admin role. Screening sessions allow claim-by-update.
  </done>
</task>

<task type="auto">
  <name>Task 2: Session claiming server action and auth flow updates</name>
  <files>src/app/screening/actions.ts, src/app/(auth)/auth/callback/route.ts, src/app/(auth)/signup/page.tsx, src/components/auth/SignupForm.tsx</files>
  <action>
**1. Add claimGuestSession server action to `src/app/screening/actions.ts`:**

```typescript
export async function claimGuestSession(sessionId: string): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { error: "You must be logged in to save screening results." };
  }

  // Verify session exists and is unclaimed (user_id IS NULL)
  const { data: session } = await supabase
    .from("screening_sessions")
    .select("id, user_id")
    .eq("id", sessionId)
    .single();

  if (!session) {
    return { error: "Screening session not found." };
  }

  if (session.user_id !== null) {
    // Already claimed — could be by this user or another
    if (session.user_id === user.id) {
      return { success: true }; // Already theirs
    }
    return { error: "This screening session has already been saved to an account." };
  }

  // Claim the session
  const { error: updateError } = await supabase
    .from("screening_sessions")
    .update({ user_id: user.id })
    .eq("id", sessionId)
    .is("user_id", null); // Double-check still unclaimed

  if (updateError) {
    console.error("Failed to claim session:", updateError);
    return { error: "Unable to save screening results. Please try again." };
  }

  return { success: true };
}
```

Also add `createActionItemsFromResults` server action that takes a sessionId and creates action_items from the screening_results.next_steps:

```typescript
export async function createActionItemsFromResults(sessionId: string): Promise<{ success: boolean; count: number; error?: string }> {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { success: false, count: 0, error: "You must be logged in." };
  }

  // Fetch results for this session
  const { data: results } = await supabase
    .from("screening_results")
    .select("program_id, program_name, next_steps")
    .eq("session_id", sessionId);

  if (!results || results.length === 0) {
    return { success: true, count: 0 };
  }

  // Build action items from next_steps
  const actionItems = [];
  let sortOrder = 0;
  for (const result of results) {
    for (const step of (result.next_steps || [])) {
      actionItems.push({
        user_id: user.id,
        session_id: sessionId,
        program_id: result.program_id,
        program_name: result.program_name,
        title: step,
        sort_order: sortOrder++,
      });
    }
  }

  if (actionItems.length === 0) {
    return { success: true, count: 0 };
  }

  const { error: insertError } = await supabase
    .from("action_items")
    .insert(actionItems);

  if (insertError) {
    console.error("Failed to create action items:", insertError);
    return { success: false, count: 0, error: "Unable to create action items." };
  }

  return { success: true, count: actionItems.length };
}
```

**2. Update auth callback `src/app/(auth)/auth/callback/route.ts`:**
The callback already supports the `next` search param and redirects to it. No changes needed unless it does not properly pass through when the signup includes a `next` param. Verify the existing code already handles this — it does (line 7: `const next = searchParams.get("next") ?? "/"`). Good, no changes needed.

**3. Update SignupForm to accept optional `redirectTo` and `sessionId` props:**
Add to `src/components/auth/SignupForm.tsx`:
- Accept `redirectTo?: string` and `sessionId?: string` props
- On successful signup redirect message, if sessionId is provided, mention that results will be saved
- Pass `redirectTo` to the emailRedirectTo in signUp options: `${origin}/auth/callback?next=${encodeURIComponent(redirectTo || '/')}`

**4. Update signup page to read `next` and `sessionId` from URL search params:**
Modify `src/app/(auth)/signup/page.tsx` to be a client component or use searchParams to pass `redirectTo` and `sessionId` to SignupForm. Use `searchParams` from the page props (server component can read them):
```typescript
interface SignupPageProps {
  searchParams: Promise<{ next?: string; sessionId?: string }>;
}
```
Pass these to SignupForm.

This enables the flow: user completes screening -> sees "Save to Account" CTA -> redirected to /signup?next=/dashboard&sessionId=xxx -> signs up -> email confirmed -> callback redirects to /dashboard -> dashboard claims the session.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Read claimGuestSession and verify it checks user auth, validates session exists and is unclaimed, and updates user_id
3. Read createActionItemsFromResults and verify it reads next_steps from screening_results and inserts action_items
4. Read SignupForm and verify it accepts redirectTo prop and passes to emailRedirectTo
5. Read signup page and verify it reads searchParams and passes to SignupForm
  </verify>
  <done>
claimGuestSession server action validates session ownership and safely claims guest sessions. createActionItemsFromResults extracts next_steps into trackable action items. SignupForm supports redirectTo prop for post-signup navigation. Signup page passes URL params through.
  </done>
</task>

</tasks>

<verification>
1. Migration file exists at supabase/migrations/00007_user_accounts_dashboard.sql with bookmarks, action_items, admin RLS, session update policy
2. TypeScript types compile: `npx tsc --noEmit`
3. claimGuestSession and createActionItemsFromResults server actions exist in src/app/screening/actions.ts
4. SignupForm accepts redirectTo and sessionId props
5. Auth callback already supports `next` redirect parameter
</verification>

<success_criteria>
- Database tables (bookmarks, action_items) defined in migration with RLS
- Crisis log RLS tightened to admin-only profiles.role check
- Session claiming logic allows NULL user_id sessions to be adopted
- Action items can be auto-created from screening results next_steps
- Auth flow supports redirect after signup with session claiming context
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-user-accounts-dashboard/05-01-SUMMARY.md`
</output>
