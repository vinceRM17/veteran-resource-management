---
phase: 03-core-screening-eligibility-engine
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/eligibility/engine.ts
  - src/lib/eligibility/rules-loader.ts
  - src/lib/eligibility/confidence-scorer.ts
  - src/lib/eligibility/__tests__/engine.test.ts
autonomous: true

must_haves:
  truths:
    - "Rules engine evaluates screening answers against eligibility rules from database"
    - "Each evaluation returns programs ranked by confidence (high > medium > low)"
    - "Programs include required documents and next steps"
    - "Rules can be loaded and filtered by jurisdiction"
    - "Adding a new state/jurisdiction requires only new rules in database, not code changes"
  artifacts:
    - path: "src/lib/eligibility/engine.ts"
      provides: "Wrapper around json-rules-engine that evaluates screening answers"
      exports: ["evaluateEligibility"]
    - path: "src/lib/eligibility/rules-loader.ts"
      provides: "Loads active eligibility rules from Supabase filtered by jurisdiction"
      exports: ["loadActiveRules"]
    - path: "src/lib/eligibility/confidence-scorer.ts"
      provides: "Ranks and deduplicates program matches by confidence level"
      exports: ["rankMatches", "deduplicateMatches"]
    - path: "src/lib/eligibility/__tests__/engine.test.ts"
      provides: "Unit tests for eligibility engine with mock rules"
  key_links:
    - from: "src/lib/eligibility/engine.ts"
      to: "json-rules-engine"
      via: "Engine class from json-rules-engine package"
      pattern: "import.*Engine.*json-rules-engine"
    - from: "src/lib/eligibility/rules-loader.ts"
      to: "src/lib/supabase/server.ts"
      via: "Supabase server client for database queries"
      pattern: "createClient.*supabase/server"
    - from: "src/lib/eligibility/confidence-scorer.ts"
      to: "src/lib/db/screening-types.ts"
      via: "ProgramMatch type for return values"
      pattern: "ProgramMatch"
---

<objective>
Build the eligibility rules engine that evaluates veteran screening answers against program eligibility criteria stored in the database, returning ranked program matches with confidence scores.

Purpose: This is the intelligence layer -- it takes raw screening answers and produces actionable program recommendations. The engine must be jurisdiction-aware (ELIG-04), load rules from database (ELIG-01), and rank results by confidence (ELIG-02, ELIG-03).

Output: Eligibility engine module (engine, rules loader, confidence scorer) with unit tests proving correct evaluation behavior.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-screening-eligibility-engine/03-RESEARCH.md
@.planning/phases/03-core-screening-eligibility-engine/03-01-SUMMARY.md
@src/lib/db/screening-types.ts
@src/lib/supabase/server.ts
@src/content/documentation-checklists.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build eligibility engine with rules loader and confidence scoring</name>
  <files>
    src/lib/eligibility/engine.ts
    src/lib/eligibility/rules-loader.ts
    src/lib/eligibility/confidence-scorer.ts
  </files>
  <action>
**Rules Loader (`src/lib/eligibility/rules-loader.ts`):**

Create function to load active eligibility rules from Supabase, filtered by jurisdiction and effective date (ELIG-01, ELIG-04).

```typescript
export async function loadActiveRules(jurisdiction: string): Promise<EligibilityRule[]>
```

Implementation:
- Use Supabase server client (createClient from src/lib/supabase/server.ts)
- Query eligibility_rules table WHERE:
  - jurisdiction = parameter (default 'kentucky')
  - is_active = true
  - effective_date <= CURRENT_DATE
  - expires_date IS NULL OR expires_date > CURRENT_DATE
- Order by program_id, confidence_level
- Return typed array of EligibilityRule from screening-types.ts
- Handle query error: throw with descriptive message

Also create a utility function for caching rules in memory during a single request (Pitfall 4 from research):
```typescript
let cachedRules: Map<string, EligibilityRule[]> = new Map()
export function clearRulesCache(): void
```

The cache is request-scoped (cleared between requests in server actions). It prevents multiple database queries if evaluateEligibility is called multiple times.

**Eligibility Engine (`src/lib/eligibility/engine.ts`):**

Create the main evaluation function using json-rules-engine (ELIG-02).

```typescript
export async function evaluateEligibility(
  answers: Record<string, any>,
  rules: EligibilityRule[]
): Promise<ProgramMatch[]>
```

Implementation:
1. Create new json-rules-engine Engine instance
2. Transform each EligibilityRule into json-rules-engine format:
   - The `rule_definition` JSONB column contains the conditions in json-rules-engine format
   - Add the event with params: { programId, programName, confidence, confidenceLabel, requiredDocs, nextSteps, description }
   - Set rule priority based on confidence: high=10, medium=5, low=1 (high confidence rules evaluate first)
3. Add all rules to the engine
4. Transform screening answers into json-rules-engine facts:
   - Map answer keys to fact names (they should match directly)
   - Add derived facts:
     - `isVeteran`: true if role === 'veteran'
     - `isCaregiver`: true if role === 'caregiver'
     - `hasDisability`: true if hasServiceConnectedDisability === 'yes'
     - `incomeBelow15K`: true if householdIncome === 'under-15k'
     - `incomeBelow25K`: true if householdIncome is 'under-15k' or '15k-25k'
     - `incomeBelow40K`: true if householdIncome is 'under-15k', '15k-25k', or '25k-40k'
     - `isOver65`: true if ageRange === '65+'
     - `isEmployed`: true if employmentStatus starts with 'employed'
     - `needsArea` (dynamic): create a fact for each selected area in areasOfNeed, e.g., needsHealthcare, needsHousing
5. Run engine with facts
6. Map events to ProgramMatch objects
7. Return array of ProgramMatch results

Handle engine errors gracefully: catch and return empty array with console.error (don't crash the screening).

Set confidence labels: high -> "Likely Eligible", medium -> "Possibly Eligible", low -> "Worth Exploring".

**Confidence Scorer (`src/lib/eligibility/confidence-scorer.ts`):**

Post-processing functions for ranking and deduplicating results (ELIG-03).

```typescript
export function rankMatches(matches: ProgramMatch[]): ProgramMatch[]
```
- Sort by confidence priority: high first, then medium, then low
- Within same confidence, sort alphabetically by programName

```typescript
export function deduplicateMatches(matches: ProgramMatch[]): ProgramMatch[]
```
- When the same programId appears at multiple confidence levels (e.g., va-disability-compensation at both high and medium), keep only the highest confidence match
- This handles the multi-rule-per-program approach from the seed data

```typescript
export function enrichWithDocumentation(
  matches: ProgramMatch[],
  checklists: DocumentationChecklist[]
): ProgramMatch[]
```
- Cross-reference ProgramMatch.programId with DocumentationChecklist.programId from documentation-checklists.ts
- Merge in the detailed document list (name, description, required, howToObtain) for matched programs
- This gives results the full document preparation info from Phase 2
  </action>
  <verify>
Run `npm run build` to verify all modules compile. Verify engine.ts imports json-rules-engine correctly. Verify rules-loader.ts imports Supabase server client. Verify confidence-scorer.ts produces correctly ordered results.
  </verify>
  <done>
Rules loader queries database with jurisdiction and date filtering. Engine evaluates answers against rules using json-rules-engine. Confidence scorer ranks, deduplicates, and enriches results with documentation checklists. All modules export typed functions matching ProgramMatch interface.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for eligibility engine</name>
  <files>
    src/lib/eligibility/__tests__/engine.test.ts
  </files>
  <action>
Create comprehensive unit tests for the eligibility engine using Vitest (project test runner).

**Test structure:**

```typescript
import { describe, it, expect } from 'vitest'
import { evaluateEligibility } from '../engine'
import { rankMatches, deduplicateMatches, enrichWithDocumentation } from '../confidence-scorer'
```

**Test cases for evaluateEligibility:**

1. "returns VA disability match for veteran with service-connected disability"
   - answers: { role: 'veteran', hasServiceConnectedDisability: 'yes' }
   - rules: [mock va-disability-compensation high confidence rule]
   - expect: result contains va-disability-compensation with confidence 'high'

2. "returns VA healthcare for all veterans"
   - answers: { role: 'veteran' }
   - rules: [mock va-healthcare rule]
   - expect: result contains va-healthcare

3. "returns Medicaid for Kentucky residents with low income"
   - answers: { state: 'KY', householdIncome: 'under-15k' }
   - rules: [mock medicaid-ky high + medium rules]
   - expect: result contains medicaid-ky

4. "does not return veteran-specific programs for caregivers"
   - answers: { role: 'caregiver' }
   - rules: [mock va-disability rule with required_role='veteran']
   - expect: result does NOT contain va-disability-compensation

5. "returns empty array when no rules match"
   - answers: { role: 'veteran', state: 'CA' }
   - rules: [mock kentucky-only rules]
   - expect: result is empty array

6. "handles engine errors gracefully"
   - Pass malformed rules
   - expect: returns empty array, does not throw

**Test cases for rankMatches:**

7. "sorts high confidence before medium before low"
   - Input: [medium, low, high] matches
   - expect: [high, medium, low] order

8. "sorts alphabetically within same confidence level"
   - Input: [high-Z, high-A, high-M]
   - expect: [high-A, high-M, high-Z]

**Test cases for deduplicateMatches:**

9. "keeps highest confidence when program appears at multiple levels"
   - Input: [va-disability high, va-disability medium]
   - expect: only va-disability high remains

10. "keeps all matches when programs are different"
    - Input: [va-disability high, medicaid medium]
    - expect: both remain

**Test cases for enrichWithDocumentation:**

11. "enriches matches with documentation checklist data"
    - Input: match for va-disability-compensation + documentation checklists
    - expect: match has requiredDocs populated from checklist

Do NOT mock json-rules-engine -- test the real engine with real rule evaluation. Only mock the Supabase database calls (rules-loader tests would need mocking, but those are integration tests -- skip for now).

Create mock rule objects using the same json-rules-engine format as the seed script. Keep tests self-contained with inline rule definitions.
  </action>
  <verify>
Run `npm run test` to execute all tests. All tests should pass. Verify test file is discovered by Vitest.
  </verify>
  <done>
10+ unit tests covering: rule evaluation with various answer combinations, confidence ranking, deduplication of multi-confidence programs, documentation enrichment, error handling. All tests pass with `npm run test`.
  </done>
</task>

</tasks>

<verification>
- [ ] json-rules-engine evaluates rules correctly with screening answer facts
- [ ] Derived facts (isVeteran, hasDisability, etc.) are computed from raw answers
- [ ] Rules loader queries database with jurisdiction + date filtering
- [ ] Confidence scorer ranks high > medium > low
- [ ] Deduplication keeps highest confidence per program
- [ ] Documentation enrichment cross-references programId with checklists
- [ ] Unit tests pass with `npm run test`
- [ ] `npm run build` passes
</verification>

<success_criteria>
- evaluateEligibility takes answers + rules and returns ProgramMatch[]
- loadActiveRules queries Supabase with jurisdiction filtering
- rankMatches produces deterministic ordering
- deduplicateMatches prevents duplicate program entries
- enrichWithDocumentation adds document details from Phase 2 content
- 10+ passing unit tests with real json-rules-engine evaluation
- No hardcoded eligibility logic -- all rules come from database
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-screening-eligibility-engine/03-03-SUMMARY.md`
</output>
