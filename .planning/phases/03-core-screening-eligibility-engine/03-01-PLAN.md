---
phase: 03-core-screening-eligibility-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/00004_screening_eligibility.sql
  - src/lib/db/screening-types.ts
  - src/content/screening-questions.ts
  - src/lib/screening/schemas.ts
  - src/lib/screening/conditional-logic.ts
  - scripts/seed-eligibility-rules.ts
autonomous: true

must_haves:
  truths:
    - "Eligibility rules for 10-15 Kentucky programs exist as JSON in database"
    - "Screening questions are defined with conditional visibility rules"
    - "Per-step Zod validation schemas exist for each screening step"
    - "State/jurisdiction is a first-class entity in the rules schema"
  artifacts:
    - path: "supabase/migrations/00004_screening_eligibility.sql"
      provides: "eligibility_rules and screening_results tables with versioning"
      contains: "eligibility_rules"
    - path: "src/lib/db/screening-types.ts"
      provides: "TypeScript types for eligibility rules, screening results, and screening answers"
      exports: ["EligibilityRule", "ScreeningResult", "ScreeningAnswers"]
    - path: "src/content/screening-questions.ts"
      provides: "Question definitions for all screening steps with conditional visibility"
      exports: ["screeningQuestions", "TOTAL_STEPS"]
    - path: "src/lib/screening/schemas.ts"
      provides: "Per-step Zod validation schemas"
      exports: ["step1Schema", "step2Schema", "step3Schema", "stepSchemas"]
    - path: "src/lib/screening/conditional-logic.ts"
      provides: "Conditional field visibility rules"
      exports: ["shouldShowField", "clearDependentFields"]
    - path: "scripts/seed-eligibility-rules.ts"
      provides: "Script to insert 10-15 program rules into eligibility_rules table"
  key_links:
    - from: "src/content/screening-questions.ts"
      to: "src/lib/screening/conditional-logic.ts"
      via: "question fieldIds match conditional-logic rule keys"
      pattern: "shouldShowField.*fieldId"
    - from: "src/lib/screening/schemas.ts"
      to: "src/content/screening-questions.ts"
      via: "schema fields match question field names"
      pattern: "z\\.object"
    - from: "scripts/seed-eligibility-rules.ts"
      to: "src/lib/db/screening-types.ts"
      via: "seed data matches EligibilityRule type"
      pattern: "EligibilityRule"
---

<objective>
Create the database schema, TypeScript types, screening question content, validation schemas, and eligibility rule seed data that form the foundation for the entire screening + eligibility system.

Purpose: Everything downstream (form UI, rules engine, results page, PDF export) depends on these data structures and content definitions existing first. This plan establishes the "shape" of the entire screening flow.

Output: Migration SQL for eligibility tables, TypeScript types, screening question definitions, Zod schemas, conditional logic, and a seed script with 10-15 Kentucky benefit program rules.
</objective>

<execution_context>
@/Users/vincecain/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vincecain/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-screening-eligibility-engine/03-RESEARCH.md
@supabase/migrations/00001_initial_schema.sql
@src/content/documentation-checklists.ts
@src/lib/db/types.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create eligibility database schema and TypeScript types</name>
  <files>
    supabase/migrations/00004_screening_eligibility.sql
    src/lib/db/screening-types.ts
  </files>
  <action>
Create migration `00004_screening_eligibility.sql` with two new tables:

**eligibility_rules table:**
- id UUID PRIMARY KEY DEFAULT gen_random_uuid()
- program_id TEXT NOT NULL (matches programId in documentation-checklists.ts, e.g. "va-disability-compensation")
- program_name TEXT NOT NULL
- jurisdiction TEXT NOT NULL DEFAULT 'kentucky' (ELIG-04: state as first-class entity)
- rule_definition JSONB NOT NULL (json-rules-engine format: { conditions: { all/any: [...] }, event: { type, params } })
- confidence_level TEXT NOT NULL CHECK ('high', 'medium', 'low')
- required_role TEXT CHECK ('veteran', 'caregiver', NULL for both)
- required_docs TEXT[] NOT NULL DEFAULT '{}'
- next_steps TEXT[] NOT NULL DEFAULT '{}'
- description TEXT NOT NULL (plain language program description)
- effective_date DATE NOT NULL DEFAULT CURRENT_DATE
- expires_date DATE (NULL = currently active)
- version INT NOT NULL DEFAULT 1
- is_active BOOLEAN NOT NULL DEFAULT true
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()
- updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
- UNIQUE constraint on (program_id, jurisdiction, confidence_level, version)

**screening_results table:**
- id UUID PRIMARY KEY DEFAULT gen_random_uuid()
- session_id UUID NOT NULL REFERENCES screening_sessions(id) ON DELETE CASCADE
- program_id TEXT NOT NULL
- program_name TEXT NOT NULL
- confidence TEXT NOT NULL CHECK ('high', 'medium', 'low')
- confidence_label TEXT NOT NULL (human-readable: "Likely Eligible" or "Possibly Eligible")
- required_docs TEXT[] NOT NULL DEFAULT '{}'
- next_steps TEXT[] NOT NULL DEFAULT '{}'
- rule_version INT NOT NULL DEFAULT 1 (audit: which rule version produced this result)
- created_at TIMESTAMPTZ NOT NULL DEFAULT now()

Add index on screening_results(session_id) for fast lookup.
Add index on eligibility_rules(jurisdiction, is_active) for rule loading.

RLS policies for eligibility_rules: public SELECT (anyone can read rules), admin-only INSERT/UPDATE.
RLS policies for screening_results: same as screening_sessions (user can see own, anonymous can read by session ID).

Also add a `role` column to the existing screening_sessions table:
```sql
ALTER TABLE public.screening_sessions ADD COLUMN IF NOT EXISTS role TEXT CHECK (role IN ('veteran', 'caregiver'));
```

Create `src/lib/db/screening-types.ts` with TypeScript interfaces:
- EligibilityRule (mirrors eligibility_rules table)
- ScreeningResult (mirrors screening_results table)
- ScreeningAnswers (Record<string, string | number | boolean | string[]> - the JSONB answers shape)
- ScreeningSession (extends existing screening_sessions with role and typed answers)
- ProgramMatch (what the engine returns: programId, programName, confidence, confidenceLabel, requiredDocs, nextSteps, description)
- ConfidenceLevel type = 'high' | 'medium' | 'low'

Keep types consistent with the existing documentation-checklists.ts programId values: "va-disability-compensation", "va-healthcare", "medicaid-ky", "snap-ky", "ssi", "ssdi", "ky-hcb-waiver", "va-pension".
  </action>
  <verify>
Run `npm run build` to verify TypeScript types compile. Visually inspect migration SQL for valid syntax.
  </verify>
  <done>
Migration SQL file exists with eligibility_rules and screening_results tables, versioning columns, RLS policies, and indexes. TypeScript types file exports all screening/eligibility interfaces matching the database schema.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create screening question content, Zod schemas, conditional logic, and eligibility rule seed data</name>
  <files>
    src/content/screening-questions.ts
    src/lib/screening/schemas.ts
    src/lib/screening/conditional-logic.ts
    scripts/seed-eligibility-rules.ts
    package.json
  </files>
  <action>
**Screening Questions (`src/content/screening-questions.ts`):**

Design a 5-step screening flow (SCREEN-01: 5-7 questions):

Step 1 - Role Selection (SCREEN-02):
- "Who are you?" with options: "I am a veteran" / "I am supporting a veteran (family member, caregiver, friend)"
- Single question, large radio buttons/cards

Step 2 - Service & Demographics:
- "What state do you live in?" (dropdown, default Kentucky)
- "What is your age range?" (18-34, 35-49, 50-64, 65+)
- "What is your service era?" (Vietnam, Gulf War, Post-9/11, Other) - CONDITIONAL: only shown if role=veteran
- "Are you a caregiver for a veteran?" (Yes/No) - CONDITIONAL: only shown if role=caregiver (SCREEN-07)

Step 3 - Needs Assessment:
- "Do you have a service-connected disability?" (Yes/No/Not sure) - CONDITIONAL: role=veteran
- "What is your VA disability rating?" (0%, 10-30%, 40-60%, 70-100%, Not rated, Don't know) - CONDITIONAL: hasServiceConnectedDisability=Yes
- "Are you currently employed?" (Yes full-time, Yes part-time, No seeking, No not seeking, Retired)
- "What is your approximate household income?" (Under $15K, $15K-$25K, $25K-$40K, $40K-$60K, Over $60K, Prefer not to say)

Step 4 - Benefits & Priorities:
- "Which areas do you need help with?" (multi-select checkboxes: Healthcare, Disability compensation, Food assistance, Housing, Employment, Education/training, Mental health, Caregiver support) (SCREEN-07: caregiver support only shown if role=caregiver or isCaregiver=Yes)
- "Do you currently receive any of these benefits?" (multi-select: VA healthcare, VA disability, Medicaid, SNAP, SSI, SSDI, None)

Step 5 - Review & Submit:
- Summary of all answers with edit links back to each step

Export: `screeningQuestions` array of step definitions with field configs, `TOTAL_STEPS` constant (5).

Each question definition should include: id (string), label (string), type ('radio' | 'select' | 'checkbox-group' | 'multi-select'), options (array), required (boolean), helpText (string, optional), conditionalOn (object with fieldId and value, optional).

ALL question labels and help text MUST be written at 6th-8th grade reading level (SCREEN-08). Use short sentences (under 15 words), common words (no jargon), and direct address ("you", "your").

**Zod Schemas (`src/lib/screening/schemas.ts`):**

Create per-step validation schemas (not one big schema):
- step1Schema: role required (enum: 'veteran' | 'caregiver')
- step2Schema: state required, ageRange required, serviceEra conditional (required if role=veteran), isCaregiver conditional (required if role=caregiver)
- step3Schema: hasServiceConnectedDisability conditional (required if role=veteran), disabilityRating conditional (required if hasServiceConnectedDisability='yes'), employmentStatus required, householdIncome required
- step4Schema: areasOfNeed (array, min 1 selection), currentBenefits (array, can be empty or ['none'])

Export `stepSchemas` array indexed by step number (1-based, step 5 is review with no validation needed). Export individual schemas for direct import.

Use Zod 4 API (project uses zod ^4.3.6). Note: Zod 4 uses `z.object()`, `.check()` instead of `.refine()` for custom validations. Verify API before using.

**Conditional Logic (`src/lib/screening/conditional-logic.ts`):**

Create `shouldShowField(fieldId: string, answers: Record<string, any>): boolean` function with rules:
- serviceEra: show only when role === 'veteran'
- isCaregiver: show only when role === 'caregiver'
- hasServiceConnectedDisability: show only when role === 'veteran'
- disabilityRating: show only when hasServiceConnectedDisability === 'yes'
- caregiverSupport (in areasOfNeed): show only when role === 'caregiver' OR isCaregiver === 'yes'

Create `clearDependentFields(changedField: string, answers: Record<string, any>): Record<string, any>` function that removes orphaned values when a conditional trigger changes (Pitfall 2 from research). For example:
- If role changes from 'veteran' to 'caregiver', clear: serviceEra, hasServiceConnectedDisability, disabilityRating
- If role changes from 'caregiver' to 'veteran', clear: isCaregiver
- If hasServiceConnectedDisability changes to 'no', clear: disabilityRating

**Eligibility Rule Seed Script (`scripts/seed-eligibility-rules.ts`):**

Create a script that inserts eligibility rules for 10-15 programs (ELIG-05) using json-rules-engine format. Use the Supabase service role client (same pattern as ETL scripts in Phase 2).

Programs to seed (matching documentation-checklists.ts programIds, plus additional Kentucky programs):
1. va-disability-compensation (HIGH confidence if: isVeteran + hasServiceConnectedDisability)
2. va-disability-compensation (MEDIUM confidence if: isVeteran + not sure about disability)
3. va-healthcare (HIGH confidence if: isVeteran)
4. medicaid-ky (HIGH confidence if: state=KY + income<$25K)
5. medicaid-ky (MEDIUM confidence if: state=KY + income $25K-$40K)
6. snap-ky (HIGH confidence if: state=KY + income<$25K)
7. snap-ky (MEDIUM confidence if: state=KY + income $25K-$40K)
8. ssi (HIGH confidence if: hasDisability + income<$15K + not employed)
9. ssi (MEDIUM confidence if: hasDisability + income<$25K)
10. ssdi (HIGH confidence if: hasDisability + was employed)
11. ssdi (MEDIUM confidence if: hasDisability + not sure about employment history)
12. ky-hcb-waiver (HIGH confidence if: state=KY + age>=65 + needsHelp includes healthcare)
13. ky-hcb-waiver (MEDIUM confidence if: state=KY + hasDisability)
14. va-pension (HIGH confidence if: isVeteran + age>=65 + income<$25K)
15. va-pension (MEDIUM confidence if: isVeteran + income<$40K)

Each rule uses json-rules-engine format:
```json
{
  "conditions": {
    "all": [
      { "fact": "role", "operator": "equal", "value": "veteran" },
      { "fact": "hasServiceConnectedDisability", "operator": "equal", "value": "yes" }
    ]
  },
  "event": {
    "type": "eligible",
    "params": { "programId": "va-disability-compensation", "confidence": "high" }
  }
}
```

The seed script should:
1. Connect to Supabase with service role client
2. Delete existing rules for jurisdiction='kentucky' (idempotent re-runs)
3. Insert all rules
4. Log summary: "Seeded N rules for Kentucky programs"

Add npm script: `"seed:rules": "npx tsx scripts/seed-eligibility-rules.ts"`

Install json-rules-engine: `npm install json-rules-engine` and `npm install --save-dev @types/json-rules-engine` (if types package exists; if not, the library may include its own types).
  </action>
  <verify>
Run `npm run build` to verify all TypeScript compiles. Verify that screeningQuestions exports correctly and stepSchemas array has correct length. Verify conditional-logic functions are pure and testable (no side effects).
  </verify>
  <done>
Screening questions defined for 5 steps with plain language content. Per-step Zod schemas validate each step independently. Conditional logic handles show/hide and orphaned field cleanup. Seed script ready to populate 10-15 Kentucky eligibility rules in json-rules-engine format. `npm run seed:rules` script available in package.json.
  </done>
</task>

</tasks>

<verification>
- [ ] Migration SQL has valid syntax (eligibility_rules + screening_results tables)
- [ ] TypeScript types compile and match database schema
- [ ] Screening questions cover 5 steps with all required fields
- [ ] Zod schemas validate per-step (not full form at once)
- [ ] Conditional logic handles all show/hide rules and orphan cleanup
- [ ] Seed script can insert 10-15 rules for Kentucky programs
- [ ] All content written at 6th-8th grade reading level
- [ ] `npm run build` passes
</verification>

<success_criteria>
- Database migration ready for manual application (same pattern as Phase 2)
- All TypeScript types exported and importable
- Screening questions define a complete 5-step flow
- Zod schemas enforce per-step validation
- Conditional logic is pure functions (testable, no React dependencies)
- Seed script is idempotent (safe to re-run)
- json-rules-engine installed as dependency
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-screening-eligibility-engine/03-01-SUMMARY.md`
</output>
